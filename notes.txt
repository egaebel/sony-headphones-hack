Steps Taken
===========
* Download and unzip and decompile source from apk ripped from phone
----Didn't find anything useful in source code, but found some keys and cloudfront URLs in non-source files
* Turn on bluetooth traffic capture on phone (output to wireshark format)
* Indirectly retrieve bluetooth traffic capture from phone using adb bugreport workaround
----LG stores the bluetooth traffic capture in the system dir where normal users cannot access it!
* Root old Nexus 5 and install Sony Headphones app on it
* Use rooted Nexus 5 (first time) to capture network traffic from SOny Headphones app (this network capture required rooting)
* Analyze network traffic, calls to cloudfront, then what appears to be downloads from an S3 bucket
* "Spoof" DNS server by setting phone to talk to laptop and using "dnsspoof" program with dnsspoof.conf file, redirect all cloudfront traffic back to the laptop
----dnschef is a way better application, it's up and running
--------dnschef proxies requests by default to google and selectively "cooks" the dns lookups for other domains
* There appears to be an issue establishing the SSL connection. The app says "no internet connection" when trying to connect to my laptop
----UPDATE: This wound up being crappy SSL code on my side it seems, the cert needed the domain names in SAN format.
----Use wireshark to sniff those packets and see what's up!
--------TLS session establishment fails, from some reading at the URL below it appears that the application is using certificate pinning
------------https://blog.securityevaluators.com/how-to-view-tls-traffic-in-androids-logs-6a42ca7a6e55
--------Might be server name identification issues instead.....
------------https://en.m.wikipedia.org/wiki/Server_Name_Indication
------------https://stephanheijl.com/rustls_sni.html
* Defeat certificate pinning
----UPDATE: Certificate pinning was never a thing
----I've found an RSA cert key in the extracted apk (using apktool with the full command below). The cert is (apparently) in pkcs7 format in binary encoding (using DER). It was a pain in the ass to figure this out.
----Cert location
--------"/home/egaebel/Programs/sony-headphones-hack/base-apk--apktool-output/original/META-INF/CERT.RSA"
----apktool command
--------apktool d base.apk -o base-apk--apktool-output/
----Guide to identify apk file location for an app
--------https://gist.github.com/ctrl-freak/24ac0e61b7cf550a6945
----openssl command to convert pkcs7 cert from der to ascii
--------openssl pkcs7 -inform der -in CERT.RSA -text
----openssl command to test secure connection with server
--------openssl s_client -CAfile ../../../keys-and-certs/authority/server.crt -connect 192.168.1.64:443
----Next step (I think?) replace the pinned certificate in the APK with my own, repackage the app, self-sign the app, upload to nexus 5 and try again.
* Create mitm server (in rust) to also run on laptop, print out requests/responses
----UPDATE: No decryption needed, TLS libs do this by default of course
----Some decryption will be necessary, but using which keys?
--------The keys are ones that I set up. I create new key-certificate pairs for SSL spoofing and install the certs on my phone
* Add a self-signed certificate for my rust mitm server to actually execute the mitm attack
* Figure out request/response format and add this to the mitm server
----First just replay and listen
* Verify the whole system works end to end with no tampering
----Snoop on everything and ensure I can see it all working end-to-end

Steps To Take
==============
* Figure out audio file format!
----The audio section of the file has almost maximum entropy. It's probably encrypted (fucking why?) or maybe compressed? IDK how high entropy typically goes for compression algorithms though.
* Start tampering
----Swap out the shitty audio files from Sony with better ones (use a language besides english for this)
--------Make sure the new audio files aren't longer than the originals (shouldn't be hard, that's the goal anyway) there might be some buffer overflows that can happen in the headphones firmware
* Polish things up and make sure the headphones have the new audio loaded
* Be happier :D



Notes
=====
* https://en.m.wikipedia.org/wiki/Server_Name_Indication
* Looks like there might be a static IP for akamai CDN to serve the audio files?
----If so, I'll have to change some router settings.....
* My issues may all have stemmed from using a cert that only had a single domain name attached to it. I can now make SAN certs and am serving bdcore and music-center traffic from my mitm server!
* Everything works with my server sitting in the middle now! I have grabbed the audio file, I need to reverse engineer its encoding.
* Big info dump on the binary audio file format
----There are 3 headers, separated by 0xFFs
----The audio portion is presumably the last part (it's huge and has no more 0xFF chains)
----The audio portion is DEFINITELY encrypted
--------This was initially shown by using the entropy measurement tool binwalk
--------This was backed up VERY heavily by looking through the decompiled apk file
------------Relevant files are under the package: com.sony.songpal.automagic in the files InformationHeader.java, l.java, and a.java (yes, they're obfuscated, but legible enough). Look in InformationHeader for the most info. It's possible to send unencrypted files. Otherwise the files are encrypted with DES3 (wtf?) or AES. (Where are the keys for that!?)
----It appears that the headers should be utf-8 encoded based on reading through the code in the decompiled java files referenced above, but reading them in that format isn't really panning out, so I'm not sure what's up there.
----Writing a small Java program to read the file might be in order.
----Spying on bluetooth traffic again might be a good idea.
----DEFINITELY look more closely at the mitm server responses to see what the specific format is before it's saved off. (Maybe something got changed when I saved the file?)


openssl req -new -addext "subjectAltName = DNS:bdcore-apr-lb.bda.ndmdhs.com,DNS:musiccenter-cdn.meta.ndmdhs.com,DNS:api.iac.meta.ndmdhs.com,DNS:mds.csx.sony.com,DNS:hc01.prc.sonydna.com,DNS:info.update.sony.net" -key server.key -out server-2.csr
openssl x509 -req -extfile <(printf "subjectAltName = DNS:bdcore-apr-lb.bda.ndmdhs.com,DNS:musiccenter-cdn.meta.ndmdhs.com,DNS:api.iac.meta.ndmdhs.com,DNS:mds.csx.sony.com,DNS:hc01.prc.sonydna.com,DNS:info.update.sony.net") -in server-2.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server-2.crt -days 9999 -sha256


Current Focus (Where I left off)
================================
* Found encryption and response reading files located under: 
----/base-dex2jar.jar.src--files/com/sony/songpal
* Much of the key files appear to be under:
----/base-dex2jar.jar.src--files/com/sony/songpal/automagic
----In particular, InformationHeader.java and base-dex2jar.jar.src--files/com/sony/songpal/automagic/l.java (that's a lowercase L)
* There is AES, DES3, and NONE for encryption types.
* It seems like maybe the responses aren't being read properly in Rust since they're Java objects?